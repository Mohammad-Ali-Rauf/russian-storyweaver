#!/bin/bash
# File: russian-ai-storyteller.sh
# Description: Generate AI-corrected Russian stories with translation, vocab, exercises, and audio narration
# Requires: Ollama, Python3, ffmpeg/ffplay, jq

set -euo pipefail
IFS=$'\n\t'

# ================================
# üé® CONFIGURATION & CONSTANTS
# ================================
readonly APP_DIR="${HOME}/.local/share/russian-ai-stories"
readonly AUDIO_DIR="${APP_DIR}/audio"
readonly CONFIG_DIR="${APP_DIR}/config"
readonly LOG_FILE="${APP_DIR}/russian_stories.log"

# Color codes for pretty output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly RESET='\033[0m'

# Model configuration - KEEPING YOUR ORIGINAL MODEL
readonly AI_MODEL="infidelis/GigaChat-20B-A3B-instruct-v1.5:q4_0"

# Topics database
readonly TOPICS=("–¥—Ä—É–∂–±–∞" "–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ" "—Å–µ–º—å—è" "–ª—é–±–æ–≤—å" "—Ä–∞–±–æ—Ç–∞" "—É—á—ë–±–∞" "—Å–ø–æ—Ä—Ç" "–∏—Å–∫—É—Å—Å—Ç–≤–æ" "–º—É–∑—ã–∫–∞" "–∫–Ω–∏–≥–∏")
readonly TOPIC_EMOJIS=("ü§ù" "‚úàÔ∏è" "üë®‚Äçüë©‚Äçüëß‚Äçüë¶" "üíñ" "üíº" "üìö" "‚öΩ" "üé®" "üéµ" "üìñ")

# ================================
# üöÄ INITIALIZATION & SETUP
# ================================

initialize_app() {
    echo -e "${CYAN}"
    cat << "EOF"
üìñ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó
  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë
  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë
  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë
  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë
  ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${RESET}"
    echo -e "${BLUE}           AI-Powered Russian Language Learning Assistant${RESET}"
    echo -e "${BLUE}===========================================================${RESET}"
    echo ""
    
    # Create necessary directories
    mkdir -p "$APP_DIR" "$AUDIO_DIR" "$CONFIG_DIR"
    
    check_dependencies
    setup_ollama
}

check_dependencies() {
    echo -e "${YELLOW}üîç Checking dependencies...${RESET}"
    
    local missing_deps=()
    
    # Check for required commands (REMOVED gtts Python check)
    for cmd in python3 jq ffplay; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo -e "${RED}‚ùå Missing dependencies: ${missing_deps[*]}${RESET}"
        echo -e "${YELLOW}üí° Please install missing packages and try again.${RESET}"
        exit 1
    fi
    
    # Check if python3-venv is available (needed for virtual environments)
    if ! python3 -c "import venv" 2>/dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  Python venv module not available${RESET}"
        echo -e "${CYAN}üí° Attempting to install python3-venv...${RESET}"
        
        # Try to install venv based on OS
        if command -v apt &>/dev/null; then
            sudo apt update && sudo apt install -y python3-venv
        elif command -v brew &>/dev/null; then
            brew install python3
        elif command -v dnf &>/dev/null; then
            sudo dnf install -y python3-virtualenv
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Cannot automatically install python3-venv${RESET}"
            echo -e "${CYAN}üí° Will attempt to continue anyway...${RESET}"
        fi
    fi
    
    echo -e "${GREEN}‚úÖ All core dependencies are satisfied!${RESET}"
    echo -e "${BLUE}‚ÑπÔ∏è  gTTS will be automatically installed in a virtual environment${RESET}"
}

setup_ollama() {
    if ! command -v ollama &>/dev/null; then
        echo -e "${YELLOW}üì• Ollama not found! Installing...${RESET}"
        curl -fsSL https://ollama.com/install.sh | sh
        echo -e "${GREEN}‚úÖ Ollama installed successfully!${RESET}"
    fi
    
    # Verify model is available
    if ! ollama list | grep -q "$AI_MODEL"; then
        echo -e "${YELLOW}ü§ñ Model $AI_MODEL not found. Please pull it with:${RESET}"
        echo -e "${CYAN}   ollama pull $AI_MODEL${RESET}"
        echo -e "${YELLOW}üìö You can find other models at: https://ollama.com/library${RESET}"
        exit 1
    fi
    
    echo -e "${GREEN}‚úÖ AI Model '$AI_MODEL' is ready!${RESET}"
}

# ================================
# üéØ CORE FUNCTIONALITY
# ================================

run_llm() {
    local prompt="$1"
    local max_retries=3
    local retry_count=0
    
    while [[ $retry_count -lt $max_retries ]]; do
        local response
        if response=$(ollama run "$AI_MODEL" "$prompt" 2>/dev/null | sed 's/^[[:space:]]*//; s/[[:space:]]*$//'); then
            if [[ -n "$response" ]]; then
                echo "$response"
                return 0
            fi
        fi
        
        ((retry_count++))
        echo -e "${YELLOW}‚ö†Ô∏è  AI request failed (attempt $retry_count/$max_retries)...${RESET}" >&2
        sleep 2
    done
    
    echo -e "${RED}‚ùå Failed to get response from AI after $max_retries attempts${RESET}" >&2
    return 1
}

generate_audio() {
    local story="$1"
    local filename="$2"
    
    echo -e "${CYAN}üîä Generating audio narration...${RESET}"
    
    # Create temporary directory for virtual environment
    local venv_dir="$APP_DIR/temp_audio_venv"
    
    # Cleanup function
    cleanup_audio_venv() {
        if [[ -d "$venv_dir" ]]; then
            rm -rf "$venv_dir" && echo -e "${YELLOW}üßπ Cleaned up temporary virtual environment${RESET}"
        fi
    }
    
    # Set up cleanup trap
    trap cleanup_audio_venv EXIT
    
    # Create virtual environment
    echo -e "${BLUE}üêç Setting up Python virtual environment...${RESET}"
    if ! python3 -m venv "$venv_dir"; then
        echo -e "${RED}‚ùå Failed to create virtual environment${RESET}"
        echo -e "${YELLOW}üí° Ensure python3-venv is installed on your system${RESET}"
        return 1
    fi
    
    # Install gTTS in the virtual environment
    echo -e "${BLUE}üì¶ Installing gTTS in virtual environment...${RESET}"
    if ! "$venv_dir/bin/pip" install gtts --quiet; then
        echo -e "${RED}‚ùå Failed to install gTTS${RESET}"
        cleanup_audio_venv
        return 1
    fi
    echo -e "${GREEN}‚úÖ gTTS installed successfully${RESET}"
    
    # Generate audio using the virtual environment's Python
    echo -e "${BLUE}üéµ Generating audio file...${RESET}"
    if ! "$venv_dir/bin/python3" - <<EOF
import sys
import os
from gtts import gTTS

try:
    # Ensure directory exists
    os.makedirs(os.path.dirname("$filename"), exist_ok=True)
    
    # Generate audio
    tts = gTTS("""$story""", lang='ru')
    tts.save("""$filename""")
    
    # Verify file was created
    if os.path.exists("""$filename"""):
        file_size = os.path.getsize("""$filename""")
        print(f"‚úÖ Audio generated successfully ({file_size} bytes)")
    else:
        print("‚ùå Audio file was not created")
        sys.exit(1)
        
except Exception as e:
    print(f"‚ùå Audio generation failed: {e}")
    sys.exit(1)
EOF
    then
        echo -e "${RED}‚ùå Audio generation failed${RESET}"
        cleanup_audio_venv
        return 1
    fi
    
    # Cleanup virtual environment
    cleanup_audio_venv
    trap - EXIT
    
    return 0
}

play_audio() {
    local audio_file="$1"
    
    echo ""
    read -rp "üéß Listen to this story in Russian? (y/N): " listen
    [[ "$listen" =~ ^[Yy]$ ]] || return 0
    
    # Check if audio file exists and has content
    if [[ ! -f "$audio_file" ]]; then
        echo -e "${RED}‚ùå Audio file not found: $audio_file${RESET}"
        return 1
    fi
    
    local file_size
    file_size=$(stat -f%z "$audio_file" 2>/dev/null || stat -c%s "$audio_file" 2>/dev/null)
    if [[ $file_size -eq 0 ]]; then
        echo -e "${RED}‚ùå Audio file is empty${RESET}"
        return 1
    fi
    
    echo -e "${CYAN}üîä Playing audio... (Press Ctrl+C to stop)${RESET}"
    if ffplay -nodisp -autoexit "$audio_file" >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Audio playback completed${RESET}"
    else
        echo -e "${RED}‚ùå Audio playback failed${RESET}"
        return 1
    fi
}

# ================================
# üìö STORY GENERATION
# ================================

generate_full_lesson() {
    local topic="$1"
    local difficulty="$2"
    local prompt
    
    case $difficulty in
        beginner)
            prompt="–ù–∞–ø–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–∏–π —Ä–∞—Å—Å–∫–∞–∑ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ –Ω–∞ —Ç–µ–º—É '$topic' –¥–ª—è —É—Ä–æ–≤–Ω—è A1 (–¥–æ 150 —Å–ª–æ–≤). –ü–µ—Ä–µ–≤–µ–¥–∏ —Ä–∞—Å—Å–∫–∞–∑ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π. 

–°–æ–∑–¥–∞–π —Å—Ç—Ä–æ–≥–æ JSON —Å–æ —Å–ª–µ–¥—É—é—â–∏–º–∏ –∫–ª—é—á–∞–º–∏ –∏ —Ñ–æ—Ä–º–∞—Ç–æ–º:

{
  \"story_ru\": \"<–†–∞—Å—Å–∫–∞–∑ –Ω–∞ —Ä—É—Å—Å–∫–æ–º>\",
  \"story_en\": \"<English translation>\",
  \"vocab\": [
    {\"word\": \"<—Å–ª–æ–≤–æ>\", \"translation\": \"<translation>\", \"pos\": \"<—á–∞—Å—Ç—å —Ä–µ—á–∏>\"}
  ],
  \"exercises\": [
    {\"type\": \"fill-in\", \"question\": \"<–≤–æ–ø—Ä–æ—Å>\", \"answer\": \"<–æ—Ç–≤–µ—Ç>\"},
    {\"type\": \"true-false\", \"question\": \"<–≤–æ–ø—Ä–æ—Å>\", \"answer\": true},
    {\"type\": \"qna\", \"question\": \"<–≤–æ–ø—Ä–æ—Å>\", \"answer\": \"<–æ—Ç–≤–µ—Ç>\"}
  ]
}

–í–ï–†–ù–ò –¢–û–õ–¨–ö–û JSON! –ù–∏–∫–∞–∫–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤, –Ω–∏–∫–∞–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –≤–Ω–µ JSON, –Ω–∏–∫–∞–∫–∏—Ö markdown –±–ª–æ–∫–æ–≤. –¢–æ–ª—å–∫–æ —á–∏—Å—Ç—ã–π JSON."
            ;;
        intermediate)
            prompt="–ù–∞–ø–∏—à–∏ —Ä–∞—Å—Å–∫–∞–∑ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ –Ω–∞ —Ç–µ–º—É '$topic' –¥–ª—è —É—Ä–æ–≤–Ω—è A2‚ÄìB1 (–¥–æ 300 —Å–ª–æ–≤). –ü–µ—Ä–µ–≤–µ–¥–∏ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π. 

–°–æ–∑–¥–∞–π —Å—Ç—Ä–æ–≥–æ JSON —Å –∫–ª—é—á–∞–º–∏ story_ru, story_en, vocab –∏ exercises. –§–æ—Ä–º–∞—Ç vocab –∏ exercises —Ç–∞–∫–æ–π –∂–µ, –∫–∞–∫ –≤ beginner.

–í–ï–†–ù–ò –¢–û–õ–¨–ö–û JSON! –ù–∏–∫–∞–∫–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤, –Ω–∏–∫–∞–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –≤–Ω–µ JSON, –Ω–∏–∫–∞–∫–∏—Ö markdown –±–ª–æ–∫–æ–≤. –¢–æ–ª—å–∫–æ —á–∏—Å—Ç—ã–π JSON."
            ;;
        advanced)
            prompt="–ù–∞–ø–∏—à–∏ —Ä–∞—Å—Å–∫–∞–∑ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ –Ω–∞ —Ç–µ–º—É '$topic' –¥–ª—è —É—Ä–æ–≤–Ω—è B2‚ÄìC1 (–¥–æ 500 —Å–ª–æ–≤). –ü–µ—Ä–µ–≤–µ–¥–∏ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π. 

–°–æ–∑–¥–∞–π —Å—Ç—Ä–æ–≥–æ JSON —Å –∫–ª—é—á–∞–º–∏ story_ru, story_en, vocab –∏ exercises. –§–æ—Ä–º–∞—Ç vocab –∏ exercises —Ç–∞–∫–æ–π –∂–µ, –∫–∞–∫ –≤ beginner.

–í–ï–†–ù–ò –¢–û–õ–¨–ö–û JSON! –ù–∏–∫–∞–∫–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤, –Ω–∏–∫–∞–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –≤–Ω–µ JSON, –Ω–∏–∫–∞–∫–∏—Ö markdown –±–ª–æ–∫–æ–≤. –¢–æ–ª—å–∫–æ —á–∏—Å—Ç—ã–π JSON."
            ;;
    esac

    echo -e "${MAGENTA}ü§ñ Generating story, translation, vocab, and exercises...${RESET}"
    run_llm "$prompt"
}

validate_and_parse_json() {
    local json_output="$1"
    
    # Create a temporary Python script to avoid heredoc issues
    local temp_python_script="$APP_DIR/temp_validate.py"
    
    cat > "$temp_python_script" << 'PYTHON_EOF'
import sys, json, re

text = sys.argv[1]

# Clean the input - remove markdown code blocks and surrounding text
text = re.sub(r'^```json\s*', '', text, flags=re.IGNORECASE)
text = re.sub(r'\s*```$', '', text)
text = re.sub(r'^JSON:\s*', '', text, flags=re.IGNORECASE)

# Extract JSON between first { and last }
start_idx = text.find('{')
end_idx = text.rfind('}') + 1

if start_idx == -1 or end_idx == 0:
    print("‚ùå No JSON structure found", file=sys.stderr)
    sys.exit(1)

json_text = text[start_idx:end_idx]

try:
    obj = json.loads(json_text)
except json.JSONDecodeError as e:
    print(f"‚ùå JSON parsing failed: {e}", file=sys.stderr)
    sys.exit(1)

# Validate structure
required_keys = ["story_ru", "story_en", "vocab", "exercises"]
for k in required_keys:
    if k not in obj:
        print(f"‚ùå Missing required key: {k}", file=sys.stderr)
        sys.exit(1)

# Fix vocab format if needed
if not isinstance(obj["vocab"], list):
    print("‚ùå Vocab must be a list", file=sys.stderr)
    sys.exit(1)

# Convert vocab to proper format if it's in different structure
fixed_vocab = []
for item in obj["vocab"]:
    if isinstance(item, str):
        # Simple string - convert to object
        fixed_vocab.append({"word": item, "translation": "unknown", "pos": "unknown"})
    elif isinstance(item, dict):
        # Already an object, ensure it has required fields
        fixed_item = item.copy()
        if "word" not in fixed_item:
            fixed_item["word"] = "unknown"
        if "translation" not in fixed_item:
            fixed_item["translation"] = "unknown"
        if "pos" not in fixed_item:
            fixed_item["pos"] = "unknown"
        fixed_vocab.append(fixed_item)
    else:
        # Unknown format, skip
        continue

obj["vocab"] = fixed_vocab

# Fix exercises format if needed
if not isinstance(obj["exercises"], list):
    # Try to convert from object format to list format
    if isinstance(obj["exercises"], dict):
        fixed_exercises = []
        for ex_type, ex_data in obj["exercises"].items():
            if isinstance(ex_data, list):
                for ex_item in ex_data:
                    if isinstance(ex_item, dict) and "question" in ex_item:
                        fixed_exercises.append({
                            "type": ex_type,
                            "question": ex_item["question"],
                            "answer": ex_item.get("answer", "unknown")
                        })
                    elif isinstance(ex_item, str):
                        fixed_exercises.append({
                            "type": ex_type,
                            "question": ex_item,
                            "answer": "unknown"
                        })
            elif isinstance(ex_data, str):
                fixed_exercises.append({
                    "type": ex_type,
                    "question": ex_data,
                    "answer": "unknown"
                })
        obj["exercises"] = fixed_exercises
    else:
        print("‚ùå Exercises must be a list or object", file=sys.stderr)
        sys.exit(1)

# Ensure all exercises have required fields
for i, ex in enumerate(obj["exercises"]):
    if not isinstance(ex, dict):
        obj["exercises"][i] = {"type": "unknown", "question": str(ex), "answer": "unknown"}
    else:
        if "type" not in ex:
            ex["type"] = "unknown"
        if "question" not in ex:
            ex["question"] = "unknown"
        if "answer" not in ex:
            ex["answer"] = "unknown"

print(json.dumps(obj, ensure_ascii=False, indent=2))
PYTHON_EOF

    # Run the Python script and capture output
    local result
    if result=$(python3 "$temp_python_script" "$json_output" 2>&1); then
        echo "$result"
        rm -f "$temp_python_script"
        return 0
    else
        echo "$result" >&2
        rm -f "$temp_python_script"
        return 1
    fi
}

# ================================
# üíæ STORY MANAGEMENT
# ================================

save_story() {
    local json_data="$1" topic="$2" level="$3"
    
    local folder="$APP_DIR/$(date +%Y-%m)"
    local archive_folder="$APP_DIR/archive"
    mkdir -p "$folder" "$archive_folder"
    
    # Find next available number
    local i=1
    while [[ -f "$folder/story-$(printf '%03d' $i).json" ]]; do
        ((i++))
    done
    
    local filename="$folder/story-$(printf '%03d' $i).json"
    local archive_file="$archive_folder/$(date +%Y-%m-%d)-story-$(printf '%03d' $i).json"
    
    # Save to current month folder
    echo "$json_data" > "$filename"
    
    # Also save to archive with date
    echo "$json_data" > "$archive_file"
    
    echo -e "${GREEN}‚úÖ Story saved to:${RESET}"
    echo -e "   ${CYAN}$filename${RESET}"
    echo -e "   ${BLUE}$archive_file${RESET}"
}

# ================================
# üéÆ LESSON RUNNER
# ================================

run_lesson() {
    local difficulty="$1" topic="$2"
    
    clear
    echo -e "${CYAN}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë               RUSSIAN LESSON                 ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${RESET}"
    echo -e "üé≠ ${BOLD}TOPIC:${RESET} ${MAGENTA}$topic${RESET} | üìä ${BOLD}LEVEL:${RESET} ${YELLOW}$difficulty${RESET}"
    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${RESET}"
    echo ""

    # Generate lesson content
    local json_output
    if ! json_output=$(generate_full_lesson "$topic" "$difficulty"); then
        echo -e "${RED}‚ùå Failed to generate lesson content${RESET}"
        return 1
    fi

    # Clean and validate JSON
    local valid_json
    if ! valid_json=$(validate_and_parse_json "$json_output"); then
        echo -e "${RED}‚ùå Invalid JSON response from AI${RESET}"
        echo -e "${YELLOW}üìù Raw output for debugging:${RESET}"
        echo "$json_output"
        return 1
    fi

    # Extract content
    local story_ru story_en vocab_json exercises_json
    story_ru=$(echo "$valid_json" | jq -r '.story_ru')
    story_en=$(echo "$valid_json" | jq -r '.story_en')
    vocab_json=$(echo "$valid_json" | jq -c '.vocab')
    exercises_json=$(echo "$valid_json" | jq -c '.exercises')

    # Display Russian story
    echo -e "${GREEN}üìñ RUSSIAN STORY:${RESET}"
    echo -e "${WHITE}$story_ru${RESET}"
    echo ""

    # Display English translation
    echo -e "${BLUE}üåç ENGLISH TRANSLATION:${RESET}"
    echo -e "${WHITE}$story_en${RESET}"
    echo ""

    # Display vocabulary
    echo -e "${YELLOW}üìö VOCABULARY:${RESET}"
    echo "$vocab_json" | jq -r '.[] | "   \(.word) (\(.pos)) - \(.translation)"' | while read -r line; do
        echo -e "   ${CYAN}‚Ä¢${RESET} $line"
    done
    echo ""

    # Generate audio with virtual environment
    local audio_file="$AUDIO_DIR/$(date +%Y-%m-%d)-$topic-$difficulty.mp3"
    if generate_audio "$story_ru" "$audio_file"; then
        play_audio "$audio_file"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Audio generation failed, but story was saved successfully${RESET}"
    fi

    # Save story
    save_story "$valid_json" "$topic" "$difficulty"

    # Display exercises
    echo -e "${MAGENTA}üéØ EXERCISES:${RESET}"
    echo "$exercises_json" | jq -r '.[] | "\(.type | ascii_upcase): \(.question)"' | while read -r line; do
        echo -e "   ${MAGENTA}‚Ä¢${RESET} $line"
    done
    echo ""
}

# ================================
# üé™ USER INTERFACE
# ================================

show_main_menu() {
    clear
    echo -e "${CYAN}"
    cat << "EOF"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           RUSSIAN AI STORYTELLER            ‚ïë
‚ïë                 MAIN MENU                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${RESET}"
    
    echo -e "${BOLD}üéØ CHOOSE LEVEL:${RESET}"
    echo -e "   ${GREEN}1.${RESET} üü¢ Beginner (A1)"
    echo -e "   ${YELLOW}2.${RESET} üü° Intermediate (A2-B1)" 
    echo -e "   ${RED}3.${RESET} üî¥ Advanced (B2-C1)"
    echo -e "   ${MAGENTA}4.${RESET} üé≤ Random topic & level"
    echo -e "   ${BLUE}5.${RESET} üìä Show stats"
    echo -e "   ${WHITE}6.${RESET} üö™ Exit"
    echo ""
}

show_topic_menu() {
    echo -e "${BOLD}üé≠ CHOOSE TOPIC:${RESET}"
    for i in "${!TOPICS[@]}"; do
        local emoji="${TOPIC_EMOJIS[$i]}"
        local topic="${TOPICS[$i]}"
        echo -e "   ${CYAN}$((i+1)).${RESET} $emoji $topic"
    done
    echo ""
}

get_user_choice() {
    local prompt="$1"
    read -rp "$prompt" choice
    echo "$choice"
}

show_stats() {
    local total_stories=0
    local total_audio=0
    
    if [[ -d "$APP_DIR" ]]; then
        total_stories=$(find "$APP_DIR" -name "*.json" -type f | wc -l)
        total_audio=$(find "$AUDIO_DIR" -name "*.mp3" -type f 2>/dev/null | wc -l)
    fi
    
    clear
    echo -e "${CYAN}üìä APPLICATION STATISTICS${RESET}"
    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${RESET}"
    echo ""
    echo -e "üìÅ ${BOLD}Storage Directory:${RESET} ${YELLOW}$APP_DIR${RESET}"
    echo ""
    echo -e "üìö ${GREEN}Total Stories:${RESET} ${WHITE}$total_stories${RESET}"
    echo -e "üîä ${BLUE}Total Audio Files:${RESET} ${WHITE}$total_audio${RESET}"
    echo ""
    
    if [[ $total_stories -gt 0 ]]; then
        echo -e "${BOLD}Recent Stories:${RESET}"
        find "$APP_DIR" -name "*.json" -type f -exec ls -lt {} + 2>/dev/null | head -5 | while read -r line; do
            echo -e "   ${CYAN}‚Ä¢${RESET} $line"
        done
    fi
    
    echo ""
    read -n 1 -s -r -p "   Press any key to continue..."
}

# ================================
# üéØ MAIN APPLICATION FLOW
# ================================

main() {
    initialize_app
    
    while true; do
        show_main_menu
        local choice
        choice=$(get_user_choice "Your choice [1-6]: ")
        
        case $choice in
            1) difficulty="beginner" ;;
            2) difficulty="intermediate" ;;
            3) difficulty="advanced" ;;
            4) 
                # Random topic and level
                local levels=("beginner" "intermediate" "advanced")
                difficulty="${levels[$((RANDOM % 3))]}"
                topic="${TOPICS[$((RANDOM % ${#TOPICS[@]}))]}"
                run_lesson "$difficulty" "$topic"
                continue
                ;;
            5) 
                show_stats
                continue
                ;;
            6) 
                echo ""
                echo -e "${GREEN}–°–ø–∞—Å–∏–±–æ –∑–∞ –∏–∑—É—á–µ–Ω–∏–µ —Ä—É—Å—Å–∫–æ–≥–æ! –î–æ –≤—Å—Ç—Ä–µ—á–∏! üëã${RESET}"
                echo ""
                exit 0
                ;;
            *) 
                echo -e "${RED}‚ùå Invalid choice. Please try again.${RESET}"
                sleep 1
                continue
                ;;
        esac
        
        show_topic_menu
        local topic_choice
        topic_choice=$(get_user_choice "Choose topic [1-${#TOPICS[@]}]: ")
        
        if [[ "$topic_choice" =~ ^[0-9]+$ ]] && [[ "$topic_choice" -ge 1 ]] && [[ "$topic_choice" -le ${#TOPICS[@]} ]]; then
            local topic_index=$((topic_choice - 1))
            topic="${TOPICS[$topic_index]}"
            
            echo ""
            echo -e "${MAGENTA}üöÄ Launching lesson: ${YELLOW}$topic${RESET} | ${CYAN}$difficulty${RESET}${RESET}"
            echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${RESET}"
            sleep 1
            
            if run_lesson "$difficulty" "$topic"; then
                echo -e "${GREEN}‚úÖ Lesson completed successfully!${RESET}"
            else
                echo -e "${RED}‚ùå Lesson failed. Please try again.${RESET}"
            fi
        else
            echo -e "${RED}‚ùå Invalid topic choice.${RESET}"
            sleep 1
            continue
        fi
        
        echo ""
        read -rp "üîÑ Generate another story? (y/N): " again
        if [[ ! "$again" =~ ^[Yy]$ ]]; then
            echo ""
            echo -e "${GREEN}–£–¥–∞—á–∏ –≤ –∏–∑—É—á–µ–Ω–∏–∏ —Ä—É—Å—Å–∫–æ–≥–æ —è–∑—ã–∫–∞! üá∑üá∫${RESET}"
            echo -e "${CYAN}–î–æ —Å–∫–æ—Ä–æ–π –≤—Å—Ç—Ä–µ—á–∏! üëã${RESET}"
            echo ""
            break
        fi
    done
}

# ================================
# üöÄ START THE APPLICATION
# ================================

# Handle script interrupts gracefully
trap 'echo -e "\n${RED}‚ùå Script interrupted. Exiting...${RESET}"; exit 1' INT TERM

# Run the main function
main "$@"
